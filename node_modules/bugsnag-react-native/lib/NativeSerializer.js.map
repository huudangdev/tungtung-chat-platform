{"version":3,"sources":["../src/NativeSerializer.js"],"names":["isError","require","allowedMapObjectTypes","serializeForNativeLayer","map","maxDepth","depth","seen","Set","add","output","extractErrorDetails","key","hasOwnProperty","call","value","undefined","includes","isNaN","type","String","has","console","warn","err","message","stack","name","module","exports"],"mappings":"AAAA,GAAMA,SAAUC,QAAQ,SAAR,CAAhB;;AAEA,GAAMC,uBAAwB,CAAE,QAAF,CAAY,QAAZ,CAAsB,SAAtB,CAA9B;;;;;;AAMA,GAAMC,yBAA0B,QAA1BA,wBAA0B,CAACC,GAAD,CAAqD,IAA/CC,SAA+C,2DAApC,EAAoC,IAAhCC,MAAgC,2DAAxB,CAAwB,IAArBC,KAAqB,2DAAd,GAAIC,IAAJ,EAAc;AACnFD,KAAKE,GAAL,CAASL,GAAT;AACA,GAAMM,QAAS,EAAf;AACA,GAAIV,QAAQI,GAAR,CAAJ,CAAkB;AAChBA,IAAMO,oBAAoBP,GAApB,CAAN;AACD;AACD,IAAK,GAAMQ,IAAX,GAAkBR,IAAlB,CAAuB;AACrB,GAAI,CAAC,GAAGS,cAAH,CAAkBC,IAAlB,CAAuBV,GAAvB,CAA4BQ,GAA5B,CAAL,CAAuC;;AAEvC,GAAMG,OAAQX,IAAIQ,GAAJ,CAAd;;;AAGA,GAAI,CAAEI,SAAF,CAAa,IAAb,EAAoBC,QAApB,CAA6BF,KAA7B,GAAwC,MAAOA,MAAP,GAAiB,QAAjB,EAA6BG,MAAMH,KAAN,CAAzE,CAAwF;AACtFL,OAAOE,GAAP,EAAc,CAAEO,KAAM,QAAR,CAAkBJ,MAAOK,OAAOL,KAAP,CAAzB,CAAd;AACD,CAFD,IAEO,IAAI,MAAOA,MAAP,GAAiB,QAArB,CAA+B;AACpC,GAAIR,KAAKc,GAAL,CAASN,KAAT,CAAJ,CAAqB;AACnBL,OAAOE,GAAP,EAAc,CAAEO,KAAM,QAAR,CAAkBJ,MAAO,YAAzB,CAAd;AACD,CAFD,IAEO,IAAIT,QAAUD,QAAd,CAAwB;AAC7BK,OAAOE,GAAP,EAAc,CAAEO,KAAM,QAAR,CAAkBJ,MAAO,sBAAzB,CAAd;AACD,CAFM,IAEA;AACLL,OAAOE,GAAP,EAAc,CAAEO,KAAM,KAAR,CAAeJ,MAAOZ,wBAAwBY,KAAxB,CAA+BV,QAA/B,CAAyCC,MAAQ,CAAjD,CAAoDC,IAApD,CAAtB,CAAd;AACD;AACF,CARM,IAQA;AACL,GAAMY,MAAO,MAAOJ,MAApB;AACA,GAAIb,sBAAsBe,QAAtB,CAA+BE,IAA/B,CAAJ,CAA0C;AACxCT,OAAOE,GAAP,EAAc,CAAEO,KAAMA,IAAR,CAAcJ,MAAOA,KAArB,CAAd;AACD,CAFD,IAEO;AACLO,QAAQC,IAAR,8CAAyDX,GAAzD,uBAAgFO,IAAhF;AACD;AACF;AACF;AACD,MAAOT,OAAP;AACD,CAhCD;;AAkCA,GAAMC,qBAAsB,QAAtBA,oBAAsB,CAACa,GAAD,CAAS;AAC3BC,OAD2B,CACFD,GADE,CAC3BC,OAD2B,CAClBC,KADkB,CACFF,GADE,CAClBE,KADkB,CACXC,IADW,CACFH,GADE,CACXG,IADW;AAEnC,MAAO,CAAEF,eAAF,CAAWC,WAAX,CAAkBC,SAAlB,CAAP;AACD,CAHD;;AAKAC,OAAOC,OAAP,CAAiB1B,uBAAjB","file":"NativeSerializer.js","sourcesContent":["const isError = require('iserror')\n\nconst allowedMapObjectTypes = [ 'string', 'number', 'boolean' ]\n\n/**\n * Convert an object into a structure with types suitable for serializing\n * across to native code.\n */\nconst serializeForNativeLayer = (map, maxDepth = 10, depth = 0, seen = new Set()) => {\n  seen.add(map)\n  const output = {}\n  if (isError(map)) {\n    map = extractErrorDetails(map)\n  }\n  for (const key in map) {\n    if (!{}.hasOwnProperty.call(map, key)) continue\n\n    const value = map[key]\n\n    // Checks for `null`, NaN, and `undefined`.\n    if ([ undefined, null ].includes(value) || (typeof value === 'number' && isNaN(value))) {\n      output[key] = { type: 'string', value: String(value) }\n    } else if (typeof value === 'object') {\n      if (seen.has(value)) {\n        output[key] = { type: 'string', value: '[circular]' }\n      } else if (depth === maxDepth) {\n        output[key] = { type: 'string', value: '[max depth exceeded]' }\n      } else {\n        output[key] = { type: 'map', value: serializeForNativeLayer(value, maxDepth, depth + 1, seen) }\n      }\n    } else {\n      const type = typeof value\n      if (allowedMapObjectTypes.includes(type)) {\n        output[key] = { type: type, value: value }\n      } else {\n        console.warn(`Could not serialize breadcrumb data for '${key}': Invalid type '${type}'`)\n      }\n    }\n  }\n  return output\n}\n\nconst extractErrorDetails = (err) => {\n  const { message, stack, name } = err\n  return { message, stack, name }\n}\n\nmodule.exports = serializeForNativeLayer\n"]}