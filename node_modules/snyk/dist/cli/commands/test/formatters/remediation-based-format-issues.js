"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const chalk_1 = require("chalk");
function formatIssuesWithRemediation(vulns, remediationInfo, options) {
    const basicVulnInfo = {};
    for (const vuln of vulns) {
        basicVulnInfo[vuln.metadata.id] = {
            title: vuln.title,
            severity: vuln.severity,
            isNew: vuln.isNew,
            name: vuln.name,
            version: vuln.version,
            fixedIn: vuln.fixedIn,
        };
    }
    const results = [chalk_1.default.bold.white('Remediation advice')];
    const upgradeTextArray = constructUpgradesText(remediationInfo.upgrade, basicVulnInfo);
    if (upgradeTextArray.length > 0) {
        results.push(upgradeTextArray.join('\n'));
    }
    const patchedTextArray = constructPatchesText(remediationInfo.patch, basicVulnInfo);
    if (patchedTextArray.length > 0) {
        results.push(patchedTextArray.join('\n'));
    }
    const unfixableIssuesTextArray = constructUnfixableText(remediationInfo.unresolved);
    if (unfixableIssuesTextArray.length > 0) {
        results.push(unfixableIssuesTextArray.join('\n'));
    }
    return results;
}
exports.formatIssuesWithRemediation = formatIssuesWithRemediation;
function constructPatchesText(patches, basicVulnInfo) {
    if (!(Object.keys(patches).length > 0)) {
        return [];
    }
    const patchedTextArray = [chalk_1.default.bold.green('Patchable issues:')];
    for (const id of Object.keys(patches)) {
        // todo: add vulnToPatch package name
        const packageAtVersion = `${basicVulnInfo[id].name}@${basicVulnInfo[id].version}`;
        const patchedText = `\n  Patch available for ${chalk_1.default.bold.whiteBright(packageAtVersion)}\n`;
        const thisPatchFixes = formatIssue(id, basicVulnInfo[id].title, basicVulnInfo[id].severity, basicVulnInfo[id].isNew);
        patchedTextArray.push(patchedText + thisPatchFixes);
    }
    return patchedTextArray;
}
function constructUpgradesText(upgrades, basicVulnInfo) {
    if (!(Object.keys(upgrades).length > 0)) {
        return [];
    }
    const upgradeTextArray = [chalk_1.default.bold.green('Upgradable Issues:')];
    for (const upgrade of Object.keys(upgrades)) {
        const upgradeDepTo = _.get(upgrades, [upgrade, 'upgradeTo']);
        const vulnIds = _.get(upgrades, [upgrade, 'vulns']);
        const upgradeText = `\n  Upgrade ${chalk_1.default.bold.whiteBright(upgrade)} to ${chalk_1.default.bold.whiteBright(upgradeDepTo)} to fix\n`;
        const thisUpgradeFixes = vulnIds
            .map((id) => formatIssue(id, basicVulnInfo[id].title, basicVulnInfo[id].severity, basicVulnInfo[id].isNew))
            .join('\n');
        upgradeTextArray.push(upgradeText + thisUpgradeFixes);
    }
    return upgradeTextArray;
}
function constructUnfixableText(unresolved) {
    if (!(unresolved.length > 0)) {
        return [];
    }
    const unfixableIssuesTextArray = [chalk_1.default.bold.white('Non-fixable issues:')];
    for (const issue of unresolved) {
        const packageNameAtVersion = chalk_1.default.bold.whiteBright(`\n  ${issue.packageName}@${issue.version} \n`);
        unfixableIssuesTextArray
            .push(packageNameAtVersion + formatIssue(issue.id, issue.title, issue.severity, issue.isNew));
    }
    return unfixableIssuesTextArray;
}
function formatIssue(id, title, severity, isNew) {
    const severitiesColourMapping = {
        low: {
            colorFunc(text) {
                return chalk_1.default.blueBright(text);
            },
        },
        medium: {
            colorFunc(text) {
                return chalk_1.default.yellowBright(text);
            },
        },
        high: {
            colorFunc(text) {
                return chalk_1.default.redBright(text);
            },
        },
    };
    const newBadge = isNew ? ' (new)' : '';
    return severitiesColourMapping[severity].colorFunc(`  âœ— ${chalk_1.default.bold(title)}${newBadge} [${titleCaseText(severity)} Severity]`) + `[${id}] `;
}
function titleCaseText(text) {
    return text[0].toUpperCase() + text.slice(1);
}
//# sourceMappingURL=remediation-based-format-issues.js.map